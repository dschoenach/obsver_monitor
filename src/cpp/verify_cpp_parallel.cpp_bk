// verify_cpp_parallel.cpp (Version 15 - Added Key Restriction, Rounding Options, and Error Metrics)
// - MODIFIED: Added options for restricting to common keys between experiments and rounding coordinates.
// - MODIFIED: CSV output now truncates existing files to avoid appending to old data.
// - MODIFIED: Added error metrics calculations (bias, rmse) to output.
// - No other logical changes were made.

#include <iostream>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <regex>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <cmath>
#include <algorithm>
#include <chrono>
#include <omp.h>
#include <ctime> // Added for correct date-time calculations

namespace fs = std::filesystem;

// --- Data Structures ---
struct SurfaceStation {
    int id = -1;
    double lat = -999.0, lon = -999.0, hgt = -999.0;
    double nn = -999.0, dd = -999.0, ff = -999.0, tt = -999.0, rh = -999.0, ps = -999.0;
    double pe = -999.0, qq = -999.0, vi = -999.0, td = -999.0, tx = -999.0, tn = -999.0;
    double gg = -999.0, gx = -999.0, fx = -999.0;
};
struct TempLevel {
    int station_id = -1;
    double pressure = -999.0;
    double temp = -999.0;   // TT
    double fi   = -999.0;   // FI (geopotential / height)
    double rh   = -999.0;   // RH
    double qq   = -999.0;   // Specific humidity
    double dd   = -999.0;   // Wind direction
    double ff   = -999.0;   // Wind speed
};
struct VobsData {
    std::unordered_map<int, SurfaceStation> stations;
    std::vector<TempLevel> temp_levels;
};
struct FileInfo {
    std::string path, type, experiment;
    long long base_time = 0, valid_time = 0;
    int lead_time = -1;
};
struct ResultKey {
    std::string experiment;
    int lead_time;
    std::string variable;
    long long vt_hour; // Changed to long long for full timestamp
    bool operator<(const ResultKey& other) const {
        if (experiment != other.experiment) return experiment < other.experiment;
        if (lead_time != other.lead_time) return lead_time < other.lead_time;
        if (vt_hour != other.vt_hour) return vt_hour < other.vt_hour;
        return variable < other.variable;
    }
};
struct TempResultKey {
    std::string experiment;
    int lead_time;
    std::string variable;
    double pressure_level;
    long long vt_hour; // Changed to long long for full timestamp
    bool operator<(const TempResultKey& other) const {
        if (experiment != other.experiment) return experiment < other.experiment;
        if (lead_time != other.lead_time) return lead_time < other.lead_time;
        if (vt_hour != other.vt_hour) return vt_hour < other.vt_hour;
        if (pressure_level != other.pressure_level) return pressure_level < other.pressure_level;
        return variable < other.variable;
    }
};
struct AggregatedStats {
    double sum_of_errors = 0.0, sum_of_squared_errors = 0.0;
    long count = 0;
};

// --- Value & error helper functions (ADDED) ---
static inline bool is_missing(double v){ return v < -998.0; }

static inline double get_surface_value(const SurfaceStation& s, const std::string& var){
    if(var=="NN") return s.nn;
    if(var=="DD") return s.dd;
    if(var=="FF") return s.ff;
    if(var=="TT") return s.tt;
    if(var=="RH") return s.rh;
    if(var=="PS") return s.ps;
    if(var=="PE") return s.pe;
    if(var=="QQ") return s.qq;
    if(var=="VI") return s.vi;
    if(var=="TD") return s.td;
    if(var=="TX") return s.tx;
    if(var=="TN") return s.tn;
    if(var=="GG") return s.gg;
    if(var=="GX") return s.gx;
    if(var=="FX") return s.fx;
    return -999.0;
}

static inline double get_temp_value(const TempLevel& t, const std::string& var){
    if(var=="TT") return t.temp;
    if(var=="RH") return t.rh;
    if(var=="QQ") return t.qq;
    if(var=="DD") return t.dd;
    if(var=="FF") return t.ff;
    if(var=="FI") return t.fi;
    return -999.0;
}

static inline double directional_diff(double f, double o){
    if(is_missing(f) || is_missing(o)) return -999.0;
    double d = f - o;
    while(d > 180.0) d -= 360.0;
    while(d < -180.0) d += 360.0;
    return d;
}

// --- Helper Function for Date-Time Arithmetic (REPLACED: remove mktime/localtime DST issues) ---
static inline bool is_leap(int y){
    return ( (y%4==0 && y%100!=0) || (y%400==0) );
}
static inline int days_in_month(int y,int m){
    static const int md[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    if(m==2) return md[1] + (is_leap(y)?1:0);
    return md[m-1];
}
long long add_hours_to_yyyymmddhh(long long start_time, int hours_to_add) {
    int year  = (int)(start_time / 1000000LL);
    int month = (int)((start_time / 10000LL) % 100LL);
    int day   = (int)((start_time / 100LL) % 100LL);
    int hour  = (int)(start_time % 100LL);

    long long total_hours = (long long)hour + hours_to_add;

    while (total_hours >= 24) {
        total_hours -= 24;
        day++;
        int dim = days_in_month(year, month);
        if (day > dim) {
            day = 1;
            month++;
            if (month > 12) { month = 1; year++; }
        }
    }
    while (total_hours < 0) {
        total_hours += 24;
        day--;
        if (day < 1) {
            month--;
            if (month < 1) { month = 12; year--; }
            day = days_in_month(year, month);
        }
    }
    return (long long)year * 1000000LL + (long long)month * 10000LL + (long long)day * 100LL + total_hours;
}

// --- Core Functions ---
void read_data_file(const std::string& filepath, bool is_vfld, int& version_flag, std::vector<SurfaceStation>& stations, std::vector<TempLevel>& temp_levels) {
    std::ifstream file(filepath);
    if (!file.is_open()) { return; }
    stations.clear(); temp_levels.clear();
    try {
        std::string line;
        int num_stat, num_temp;
        if(!std::getline(file, line)) return;
        std::stringstream(line) >> num_stat >> num_temp >> version_flag;

        std::vector<std::string> surface_variables;
        if (version_flag <= 3) {
            if(!std::getline(file, line)) return;
            surface_variables = {"NN","DD","FF","TT","RH","PS","PE","QQ","VI","TD","TX","TN","GG","GX","FX"};
        } else if (version_flag == 4 || version_flag == 5) {
            if(!std::getline(file, line)) return; int ninvar = std::stoi(line);
            for (int i=0; i<ninvar; ++i) { if(!std::getline(file, line)) break; std::stringstream ss(line); std::string vn; ss >> vn; surface_variables.push_back(vn); }
        }
        std::unordered_map<std::string, int> surface_col_map;
        for (size_t i = 0; i < surface_variables.size(); ++i)
            surface_col_map[surface_variables[i]] = static_cast<int>(i);
        
        stations.reserve(num_stat);
        for (int i=0; i<num_stat; ++i) {
            if (!std::getline(file, line) || line.empty()) break;
            std::stringstream line_stream(line); SurfaceStation s={}; line_stream >> s.id >> s.lat >> s.lon;
            if (!is_vfld) { line_stream >> s.hgt; }
            std::vector<double> data_values; double val; while(line_stream >> val) data_values.push_back(val);
            if (is_vfld) {
                if (surface_col_map.count("FI") && surface_col_map.at("FI")<data_values.size()) s.hgt=data_values[surface_col_map.at("FI")];
                else if (surface_col_map.count("hgt") && surface_col_map.at("hgt")<data_values.size()) s.hgt=data_values[surface_col_map.at("hgt")];
            }
            if(surface_col_map.count("NN")&&surface_col_map.at("NN")<data_values.size())s.nn=data_values[surface_col_map.at("NN")];if(surface_col_map.count("DD")&&surface_col_map.at("DD")<data_values.size())s.dd=data_values[surface_col_map.at("DD")];
            if(surface_col_map.count("FF")&&surface_col_map.at("FF")<data_values.size())s.ff=data_values[surface_col_map.at("FF")];if(surface_col_map.count("TT")&&surface_col_map.at("TT")<data_values.size())s.tt=data_values[surface_col_map.at("TT")];
            if(surface_col_map.count("RH")&&surface_col_map.at("RH")<data_values.size())s.rh=data_values[surface_col_map.at("RH")];if(surface_col_map.count("PS")&&surface_col_map.at("PS")<data_values.size())s.ps=data_values[surface_col_map.at("PS")];
            if(surface_col_map.count("PE")&&surface_col_map.at("PE")<data_values.size())s.pe=data_values[surface_col_map.at("PE")];if(surface_col_map.count("QQ")&&surface_col_map.at("QQ")<data_values.size())s.qq=data_values[surface_col_map.at("QQ")];
            if(surface_col_map.count("VI")&&surface_col_map.at("VI")<data_values.size())s.vi=data_values[surface_col_map.at("VI")];if(surface_col_map.count("TD")&&surface_col_map.at("TD")<data_values.size())s.td=data_values[surface_col_map.at("TD")];
            if(surface_col_map.count("TX")&&surface_col_map.at("TX")<data_values.size())s.tx=data_values[surface_col_map.at("TX")];if(surface_col_map.count("TN")&&surface_col_map.at("TN")<data_values.size())s.tn=data_values[surface_col_map.at("TN")];
            if(surface_col_map.count("GG")&&surface_col_map.at("GG")<data_values.size())s.gg=data_values[surface_col_map.at("GG")];if(surface_col_map.count("GX")&&surface_col_map.at("GX")<data_values.size())s.gx=data_values[surface_col_map.at("GX")];
            if(surface_col_map.count("FX")&&surface_col_map.at("FX")<data_values.size())s.fx=data_values[surface_col_map.at("FX")];
            stations.push_back(s);
        }

        if (num_temp > 0) {
            if(!std::getline(file, line) || line.empty()) return; int num_temp_lev = std::stoi(line);
            if(!std::getline(file, line) || line.empty()) return; int ninvar_temp = std::stoi(line);
            std::vector<std::string> temp_variables;
            for(int i=0; i<ninvar_temp; ++i) { if(!std::getline(file, line)) break; std::stringstream ss(line); std::string vn; ss >> vn; temp_variables.push_back(vn); }
            std::unordered_map<std::string, int> temp_col_map;
            for(size_t i=0; i<temp_variables.size(); ++i)
                temp_col_map[temp_variables[i]] = static_cast<int>(i);
            temp_levels.reserve(num_temp * num_temp_lev);
            for(int i=0; i<num_temp; ++i) {
                if (!std::getline(file, line) || line.empty()) break;
                std::stringstream header_ss(line); int station_id; header_ss >> station_id;
                for(int j=0; j<num_temp_lev; ++j) {
                    if (!std::getline(file, line)) break;
                    std::stringstream level_ss(line); std::vector<double> values; double val; while(level_ss >> val) values.push_back(val);
                    if (values.empty()) continue;
                    TempLevel tl; tl.station_id = station_id;
                    if(temp_col_map.count("PP")&&temp_col_map.at("PP")<values.size())tl.pressure=values[temp_col_map.at("PP")];
                    if(temp_col_map.count("TT")&&temp_col_map.at("TT")<values.size())tl.temp=values[temp_col_map.at("TT")];
                    if(temp_col_map.count("FI")&&temp_col_map.at("FI")<values.size())tl.fi=values[temp_col_map.at("FI")];
                    if(temp_col_map.count("RH")&&temp_col_map.at("RH")<values.size())tl.rh=values[temp_col_map.at("RH")];
                    if(temp_col_map.count("QQ")&&temp_col_map.at("QQ")<values.size())tl.qq=values[temp_col_map.at("QQ")];
                    if(temp_col_map.count("DD")&&temp_col_map.at("DD")<values.size())tl.dd=values[temp_col_map.at("DD")];
                    if(temp_col_map.count("FF")&&temp_col_map.at("FF")<values.size())tl.ff=values[temp_col_map.at("FF")];
                    temp_levels.push_back(tl);
                }
            }
        }
    } catch (const std::exception& e) {
        #pragma omp critical
        std::cerr << "Warning: Exception caught while reading " << filepath << ": " << e.what() << ". Skipping file." << std::endl;
    }
}

FileInfo parse_filename(const std::string& path) {
    std::string basename = fs::path(path).filename().string();
    FileInfo info; info.path = path;
    // Accept ONLY vfld files ending with 12 digits: YYYYMMDDHHLL (base + 2-digit lead)
    if (basename.rfind("vfld", 0) == 0) {
        std::smatch m;
        std::regex re("(20\\d{6})(\\d{2})(\\d{2})$"); // (YYYYMMDD)(HH)(LL)
        if (std::regex_search(basename, m, re)) {
            info.type = "vfld";
            std::string date_part = m[1].str();
            std::string hour_part = m[2].str();
            std::string lead_part = m[3].str();
            info.base_time = std::stoll(date_part + hour_part); // YYYYMMDDHH
            info.lead_time = std::stoi(lead_part);
            info.valid_time = add_hours_to_yyyymmddhh(info.base_time, info.lead_time);
        }
    } else if (basename.rfind("vobs", 0) == 0) {
        std::smatch m;
        std::regex re("(20\\d{6})(\\d{2})$"); // YYYYMMDDHH
        if (std::regex_search(basename, m, re)) {
            info.type = "vobs";
            info.base_time = std::stoll(m[1].str() + m[2].str());
            info.valid_time = info.base_time;
            info.experiment = "observation";
            info.lead_time = -1;
        }
    }
    return info;
}


// --- NEW: Hash & Key Utilities ---
static inline long long round_coord(double v, int dec){
    double scale = std::pow(10.0, dec);
    return static_cast<long long>(std::llround(v * scale));
}
static inline uint64_t mix64(uint64_t x){
    // SplitMix64 finalizer
    x += 0x9e3779b97f4a7c15ULL;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ULL;
    x = (x ^ (x >> 27)) * 0x94d049bb133111ebULL;
    x = x ^ (x >> 31);
    return x;
}
static inline void hash_combine(uint64_t& seed, uint64_t v){
    seed ^= mix64(v + 0x9e3779b97f4a7c15ULL + (seed<<6) + (seed>>2));
}
static uint64_t surface_key(long long base_time,long long valid_time,int station_id,
                            const std::string& var,long long rlat,long long rlon){
    uint64_t seed = 0;
    hash_combine(seed, (uint64_t)base_time);
    hash_combine(seed, (uint64_t)valid_time);
    hash_combine(seed, (uint64_t)station_id);
    // variable string hashed char-wise
    uint64_t vhash = 0;
    for(unsigned char c: var) vhash = vhash*131 + c;
    hash_combine(seed, vhash);
    hash_combine(seed, (uint64_t)rlat);
    hash_combine(seed, (uint64_t)rlon);
    return seed;
}
static uint64_t temp_key(long long base_time,long long valid_time,int station_id,
                         double pressure,const std::string& var,long long rlat,long long rlon){
    uint64_t seed = 0;
    hash_combine(seed, (uint64_t)base_time);
    hash_combine(seed, (uint64_t)valid_time);
    hash_combine(seed, (uint64_t)station_id);
    // quantize pressure (Pa) to integer
    hash_combine(seed, (uint64_t)std::llround(pressure));
    uint64_t vhash = 0;
    for(unsigned char c: var) vhash = vhash*131 + c;
    hash_combine(seed, vhash);
    hash_combine(seed, (uint64_t)rlat);
    hash_combine(seed, (uint64_t)rlon);
    return seed;
}


int main(int argc, char* argv[]) {
    if (argc < 6) {
        std::cerr << "Usage: " << argv[0] << " <start_YYYYMMDDHH> <end_YYYYMMDDHH> <fcint> <vobs_dir> <vfld_exp_dir1> [<vfld_exp_dir2> ...]" << std::endl; return 1;
    }
    long long start_dt = std::stoll(argv[1]);
    long long end_dt = std::stoll(argv[2]);
    int fcint;
    try {
        fcint = std::stoi(argv[3]);
    } catch (const std::exception& e) {
        std::cerr << "Error: Invalid fcint '" << argv[3] << "'. Must be an integer." << std::endl; return 1;
    }
    const fs::path vobs_path = argv[4];
    std::vector<fs::path> experiment_paths;
    for (int i = 5; i < argc; ++i) {
        std::string a = argv[i];
        if (a.rfind("--", 0) == 0) break;          // stop when flags begin
        if (fs::exists(a)) experiment_paths.push_back(a);
        else if (a.find('/') != std::string::npos) // looks like a path but missing
            std::cerr << "[warn] Skipping non-existent experiment path: " << a << std::endl;
    }

    // --- NEW: Parse extra flags (simple manual scan to avoid large refactor) ---
    bool restrict_common = false;
    int round_dec = 2;
    {
        for(int i=1;i<argc;++i){
            if(std::string(argv[i])=="--restrict-common-keys"){
                restrict_common = true;
            } else if(std::string(argv[i])=="--round-dec" && i+1 < argc){
                round_dec = std::stoi(argv[i+1]);
            }
        }
    }

    // (Keep original positional parsing; just warn if flags appear after paths)
    if (restrict_common)
        std::cout << "[info] Common key restriction enabled (two-pass)." << std::endl;
    std::cout << "[info] round-dec = " << round_dec << std::endl;

    auto script_start_time = std::chrono::high_resolution_clock::now();
    
    std::vector<FileInfo> vfld_files;
    std::vector<FileInfo> vobs_files;
    std::cout << "Discovering and parsing filenames..." << std::endl;
    std::map<std::string, int> max_lead_time_found; // To store max lead time per experiment

    for (const auto& exp_path_raw : experiment_paths) {
        fs::path exp_path = exp_path_raw;
        std::string experiment_name = exp_path.filename().string();
        if (experiment_name.empty() || experiment_name == ".") { experiment_name = exp_path.parent_path().filename().string(); }
        max_lead_time_found[experiment_name] = 0; // Initialize max lead time

        std::cout << "Searching for vfld files for experiment '" << experiment_name << "' in: " << exp_path << std::endl;
        for (const auto& entry : fs::directory_iterator(exp_path)) {
            if (entry.is_regular_file()) {
                FileInfo info = parse_filename(entry.path().string());
                if (info.type == "vfld" && info.base_time >= start_dt && info.base_time <= end_dt) {
                    long long base_hour = info.base_time % 100;
                    if (base_hour % fcint != 0) { continue; }
                    info.experiment = experiment_name;
                    vfld_files.push_back(info);
                    if (info.lead_time > max_lead_time_found[experiment_name]) {
                        max_lead_time_found[experiment_name] = info.lead_time;
                    }
                }
            }
        }
    }
    std::cout << "Searching for vobs files in: " << vobs_path << std::endl;
    for (const auto& entry : fs::recursive_directory_iterator(vobs_path)) {
        if (entry.is_regular_file()) { FileInfo info = parse_filename(entry.path().string()); if (info.type == "vobs") vobs_files.push_back(info); }
    }
    std::cout << "Found " << vobs_files.size() << " vobs files and " << vfld_files.size() << " vfld files to process (after fcint filter)." << std::endl;
    for(const auto& pair : max_lead_time_found) {
        std::cout << "  - Max lead time found for " << pair.first << ": +" << pair.second << "h" << std::endl;
    }
    if (vfld_files.empty() || vobs_files.empty()) { std::cerr << "Error: No data files found. Please check paths and date range." << std::endl; return 1; }

    auto vobs_read_start_time = std::chrono::high_resolution_clock::now();
    std::cout << "Reading all vobs files into memory (in parallel)..." << std::endl;
    std::unordered_map<long long, VobsData> vobs_data_map;
    #pragma omp parallel for
    for (size_t i = 0; i < vobs_files.size(); ++i) {
        const auto& vobs_info = vobs_files[i];
        int version;
        std::vector<SurfaceStation> stations_vec;
        std::vector<TempLevel> temp_levels_vec;
        read_data_file(vobs_info.path, false, version, stations_vec, temp_levels_vec);
        #pragma omp critical
        {
            for (const auto& station : stations_vec) { vobs_data_map[vobs_info.valid_time].stations[station.id] = station; }
            vobs_data_map[vobs_info.valid_time].temp_levels.insert(vobs_data_map[vobs_info.valid_time].temp_levels.end(), temp_levels_vec.begin(), temp_levels_vec.end());
        }
    }
    auto vobs_read_end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> vobs_read_duration = vobs_read_end_time - vobs_read_start_time;
    std::cout << "--- Time to read all vobs files: " << vobs_read_duration.count() << " seconds ---" << std::endl;

    // --- NEW: Data structures for key intersection ---
    std::unordered_set<uint64_t> surface_intersection;
    std::unordered_set<uint64_t> temp_intersection;
    bool first_experiment_keys = true;

    // Helper lambda to intersect
    auto intersect_in_place = [](std::unordered_set<uint64_t>& base,
                                 const std::unordered_set<uint64_t>& incoming){
        for(auto it = base.begin(); it != base.end(); ){
            if (incoming.find(*it)==incoming.end()){
                it = base.erase(it);
            } else {
                ++it;
            }
        }
    };

    // ---------------- PASS 1: Build per-experiment key sets ----------------
    if (restrict_common){
        std::cout << "[pass1] Building per-experiment key sets..." << std::endl;

        // We reuse file discovery lists: vfld_files, vobs_data_map will be needed anyway
        // Ensure vobs already loaded (move vobs reading earlier if needed)
        // If vobs reading in original code happens later, move that block before this pass.

        // Build quick access to vobs (already built later)—so we move original vobs reading earlier:
        // ...existing code (adjust ordering in real file) ...

        // Per experiment temporary sets
        std::map<std::string, std::unordered_set<uint64_t>> exp_surface_keys;
        std::map<std::string, std::unordered_set<uint64_t>> exp_temp_keys;

        for (const auto& fi : vfld_files){
            // Need experiment name (ensure FileInfo has field 'experiment' populated where files are pushed)
            if (fi.experiment.empty()) continue;
            auto it_vobs = vobs_data_map.find(fi.valid_time);
            if (it_vobs == vobs_data_map.end()) continue;

            int version;
            std::vector<SurfaceStation> vfld_stations_vec;
            std::vector<TempLevel> vfld_temp_levels_vec;
            read_data_file(fi.path, true, version, vfld_stations_vec, vfld_temp_levels_vec);

            const auto& vobs_stations = it_vobs->second.stations;
            const auto& vobs_temp_levels = it_vobs->second.temp_levels;

            // Surface matches
            for(const auto& st_f : vfld_stations_vec){
                auto it_obs = vobs_stations.find(st_f.id);
                if (it_obs == vobs_stations.end()) continue;
                const auto& st_o = it_obs->second;

                long long rlat = round_coord(st_o.lat, round_dec);
                long long rlon = round_coord(st_o.lon, round_dec);

                // List of variables actually compared in original loop (replicate the subset you compute errors for)
                const std::vector<std::string> vars = {"TT","RH","FF","DD","PS","QQ","TD","TX","TN","NN","PE","VI","GG","GX","FX"};
                for(const auto& var : vars){
                    // (We don't check actual availability here; optional: skip if either value missing)
                    uint64_t k = surface_key(fi.base_time, fi.valid_time, st_f.id, var, rlat, rlon);
                    exp_surface_keys[fi.experiment].insert(k);
                }
            }

            // Temp levels: build index for vobs by (station, pressure)
            if (!vfld_temp_levels_vec.empty() && !vobs_temp_levels.empty()){
                std::unordered_multimap<long long, const TempLevel*> vobs_index;
                vobs_index.reserve(vobs_temp_levels.size()*2);
                auto mk = [](int sid,double pres)->long long{
                    // Combine into 64-bit: high 32 bits station, low 32 bits rounded pressure (Pa)
                    return ( (long long)sid << 32 ) ^ (long long)std::llround(pres);
                };
                for(const auto& tl : vobs_temp_levels){
                    vobs_index.emplace(mk(tl.station_id, tl.pressure), &tl);
                }
                for(const auto& tl_f : vfld_temp_levels_vec){
                    auto range = vobs_index.equal_range(mk(tl_f.station_id, tl_f.pressure));
                    if (range.first == range.second) continue;
                    // Station meta (lat/lon) from surface optional: reuse surface map if exists
                    double lat = 0.0, lon = 0.0;
                    auto sit = vobs_stations.find(tl_f.station_id);
                    if (sit != vobs_stations.end()){
                        lat = sit->second.lat;
                        lon = sit->second.lon;
                    }
                    long long rlat = round_coord(lat, round_dec);
                    long long rlon = round_coord(lon, round_dec);

                    const std::vector<std::string> tvars = {"TT","RH","FF","DD","QQ","FI"};
                    for(const auto& var : tvars){
                        uint64_t k = temp_key(fi.base_time, fi.valid_time, tl_f.station_id,
                                              tl_f.pressure, var, rlat, rlon);
                        exp_temp_keys[fi.experiment].insert(k);
                    }
                }
            }
        }

        // Compute intersection across experiments
        for (const auto& p : exp_surface_keys){
            if (first_experiment_keys){
                surface_intersection = p.second;
            } else {
                intersect_in_place(surface_intersection, p.second);
            }
            first_experiment_keys = false;
        }
        first_experiment_keys = true;
        for (const auto& p : exp_temp_keys){
            if (first_experiment_keys){
                temp_intersection = p.second;
            } else {
                intersect_in_place(temp_intersection, p.second);
            }
            first_experiment_keys = false;
        }
        std::cout << "[pass1] Surface common keys: " << surface_intersection.size()
                  << " | Temp common keys: " << temp_intersection.size() << std::endl;
    }

    // ---------------- PASS 2: Main verification (modified to filter) ----------------
    std::cout << "Starting main verification loop (in parallel)..." << std::endl;

    auto verification_start_time = std::chrono::high_resolution_clock::now(); // <<< ADDED

    std::map<ResultKey, AggregatedStats> final_surface_results;
    std::map<TempResultKey, AggregatedStats> final_temp_results;

    const std::vector<std::string> supported_variables = {"NN","DD","FF","TT","RH","PS","PE","QQ","VI","TD","TX","TN","GG","GX","FX","FI"};

    #pragma omp parallel
    {
        std::map<ResultKey, AggregatedStats> local_surface_results;
        std::map<TempResultKey, AggregatedStats> local_temp_results;

        #pragma omp for nowait
        for (size_t i = 0; i < vfld_files.size(); ++i) {
            const auto& vfld_info = vfld_files[i];
            auto it_vobs = vobs_data_map.find(vfld_info.valid_time);
            if (it_vobs == vobs_data_map.end()) continue;

            const auto& vobs_stations = it_vobs->second.stations;
            const auto& vobs_temp_levels = it_vobs->second.temp_levels;

            int version;
            std::vector<SurfaceStation> vfld_stations_vec;
            std::vector<TempLevel> vfld_temp_levels_vec;
            read_data_file(vfld_info.path, true, version, vfld_stations_vec, vfld_temp_levels_vec);

            // Surface loop (pseudo: fill real error calc code where original had ...)
            for (const auto& station_vfld : vfld_stations_vec) {
                auto it_station_vobs = vobs_stations.find(station_vfld.id);
                if (it_station_vobs == vobs_stations.end()) continue;

                const auto& s_obs = it_station_vobs->second;
                long long rlat = round_coord(s_obs.lat, round_dec);
                long long rlon = round_coord(s_obs.lon, round_dec);

                // Example variable subset; integrate actual error calc where original code has logic.
                const std::vector<std::string> vars = {"TT","RH","FF","DD","PS","QQ","TD","TX","TN","NN","PE","VI","GG","GX","FX"};
                for(const auto& var : vars){
                    if (restrict_common){
                        uint64_t k = surface_key(vfld_info.base_time, vfld_info.valid_time,
                                                 station_vfld.id, var, rlat, rlon);
                        if (surface_intersection.find(k)==surface_intersection.end()) continue;
                    }
                    double fval = get_surface_value(station_vfld, var);
                    double oval = get_surface_value(s_obs, var);
                    if (is_missing(fval) || is_missing(oval)) continue;

                    double error;
                    if (var == "DD") {
                        error = directional_diff(fval, oval);
                        if (is_missing(error)) continue;
                    } else {
                        error = fval - oval;
                    }

                    ResultKey rk{vfld_info.experiment, vfld_info.lead_time, var, vfld_info.valid_time};
                    auto& agg = local_surface_results[rk];
                    agg.sum_of_errors += error;
                    agg.sum_of_squared_errors += error*error;
                    agg.count += 1;
                }
            }

            // Temp levels
            if (!vfld_temp_levels_vec.empty() && !vobs_temp_levels.empty()) {
                std::unordered_multimap<long long, const TempLevel*> vobs_index;
                vobs_index.reserve(vobs_temp_levels.size()*2);
                auto mk_key = [](int sid, double pres)->long long{
                    return ((long long)sid << 32) ^ (long long)std::llround(pres);
                };
                for (const auto& lvl : vobs_temp_levels) {
                    vobs_index.emplace(mk_key(lvl.station_id, lvl.pressure), &lvl);
                }
                for (const auto& lvl_f : vfld_temp_levels_vec) {
                    auto range = vobs_index.equal_range(mk_key(lvl_f.station_id, lvl_f.pressure));
                    if (range.first == range.second) continue;

                    double lat = 0.0, lon = 0.0;
                    auto sit = vobs_stations.find(lvl_f.station_id);
                    if (sit != vobs_stations.end()){
                        lat = sit->second.lat;
                        lon = sit->second.lon;
                    }
                    long long rlat = round_coord(lat, round_dec);
                    long long rlon = round_coord(lon, round_dec);

                    const std::vector<std::string> tvars = {"TT","RH","FF","DD","QQ","FI"};
                    // pick the first matching obs level in range
                    const TempLevel* obs_level = (range.first != range.second) ? range.first->second : nullptr;
                    if(!obs_level) continue;

                    for(const auto& var : tvars){
                        if (restrict_common){
                            uint64_t k = temp_key(vfld_info.base_time, vfld_info.valid_time,
                                                  lvl_f.station_id, lvl_f.pressure, var, rlat, rlon);
                            if (temp_intersection.find(k)==temp_intersection.end()) continue;
                        }
                        double fval = get_temp_value(lvl_f, var);
                        double oval = get_temp_value(*obs_level, var);
                        if (is_missing(fval) || is_missing(oval)) continue;

                        double error;
                        if (var == "DD") {
                            error = directional_diff(fval, oval);
                            if (is_missing(error)) continue;
                        } else {
                            error = fval - oval;
                        }

                        TempResultKey tk{vfld_info.experiment, vfld_info.lead_time, var,
                                         lvl_f.pressure, vfld_info.valid_time};
                        auto& agg = local_temp_results[tk];
                        agg.sum_of_errors += error;
                        agg.sum_of_squared_errors += error*error;
                        agg.count += 1;
                    }
                }
            }
        }

        #pragma omp critical
        {
            for(const auto& p : local_surface_results){
                auto& g = final_surface_results[p.first];
                g.sum_of_errors += p.second.sum_of_errors;
                g.sum_of_squared_errors += p.second.sum_of_squared_errors;
                g.count += p.second.count;
            }
            for(const auto& p : local_temp_results){
                auto& g = final_temp_results[p.first];
                g.sum_of_errors += p.second.sum_of_errors;
                g.sum_of_squared_errors += p.second.sum_of_squared_errors;
                g.count += p.second.count;
            }
        }
    }
    auto verification_end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> verification_duration = verification_end_time - verification_start_time;
    std::cout << "--- Time for verification processing: " << verification_duration.count() << " seconds ---" << std::endl;
    
    // Ensure old CSVs removed to avoid stale data
    if (fs::exists("surface_metrics.csv")) fs::remove("surface_metrics.csv");
    if (fs::exists("temp_metrics.csv")) fs::remove("temp_metrics.csv");

    std::cout << "Saving surface metrics to surface_metrics.csv" << std::endl;
    std::ofstream outfile("surface_metrics.csv", std::ios::trunc);
    outfile.precision(6);
    outfile << std::fixed << "experiment,lead_time,vt_hour,obstypevar,bias,rmse,n_samples\n";
    for(const auto& pair : final_surface_results) {
        const auto& key = pair.first; const auto& stats = pair.second;
        if (stats.count > 0) {
            double bias = stats.sum_of_errors / stats.count; double rmse = std::sqrt(stats.sum_of_squared_errors / stats.count);
            outfile << key.experiment << "," << key.lead_time << "," << key.vt_hour << "," << key.variable << "," << bias << "," << rmse << "," << stats.count << "\n";
        }
    }
    outfile.close();

    std::cout << "Saving temp metrics to temp_metrics.csv" << std::endl;
    std::ofstream temp_outfile("temp_metrics.csv", std::ios::trunc);
    temp_outfile.precision(6);
    temp_outfile << std::fixed << "experiment,lead_time,vt_hour,pressure_level,obstypevar,bias,rmse,n_samples\n";
    for(const auto& pair : final_temp_results) {
        const auto& key = pair.first; const auto& stats = pair.second;
        if (stats.count > 0) {
            double bias = stats.sum_of_errors / stats.count; double rmse = std::sqrt(stats.sum_of_squared_errors / stats.count);
            temp_outfile << key.experiment << "," << key.lead_time << "," << key.vt_hour << "," << key.pressure_level << "," << key.variable
                         << "," << bias << "," << rmse << "," << stats.count << "\n";
        }
    }
    temp_outfile.close();

    auto script_end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> script_duration = script_end_time - script_start_time;
    std::cout << "\n--- Total script execution time: " << script_duration.count() << " seconds ---" << std::endl;

    return 0;
}
